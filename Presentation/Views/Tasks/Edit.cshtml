@{
    ViewData["Title"]= ViewBag.Id!=null ? "Edit Task" : "Add Task";

    <style>
       .assigned-user-img{
        width: 2.8rem;
        height: 2.8rem;
       }
    </style>
}

<section id='tasks-edit'>
    <div class="d-flex align-items-center justify-content-between mb-3">
        <h1 class="fs-2">{{ isEditMode ? "Edit Task" : "Add Task" }}</h1>
        <div class="d-flex align-items-center gap-3 justify-content-end">
            <a href='/Tasks/Index' class='btn btn-outline-secondary'>Cancel</a>
            <button :disabled='!(v$ && v$.$anyDirty) || v$.$invalid' type="button" @@click='submitForm' class='btn btn-primary'>Save</button>
        </div>
    </div>
    <form class='row'>
        @* Task Details *@
        <fieldset class="flex-grow-1 col">
            <div class="mb-3">
                <label for="exampleInputEmail1" class="form-label">Name</label>
                <input @@blur='touchField("name")' v-model='taskForm.name' type="text" class="form-control w-100" id="exampleInputEmail1" aria-describedby="emailHelp">
                <span v-if='v$ && v$.name.$error' id="emailHelp" class="text-danger small">{{v$.name.$errors[0].$message}}</span>
            </div>
            <div class="mb-3">
                <label for="exampleInputEmail1" class="form-label">Start Date</label>
                <input :disabled='isEditMode' @@blur='touchField("startDate")' v-model='taskForm.startDate' type="datetime-local" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp">
                <span v-if='v$ && v$.startDate.$error' id="emailHelp" class="text-danger small">{{v$.startDate.$errors[0].$message}}</span>
            </div>
            <div class="mb-3">
                <label for="exampleInputEmail1" class="form-label">End Date</label>
                <input @@blur='touchField("endDate")' v-model='taskForm.endDate' type="datetime-local" class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp">
                <span v-if='v$ && v$.endDate.$error' id="emailHelp" class="text-danger small">{{v$.endDate.$errors[0].$message}}</span>
            </div>
            <div class="">
                <label for="exampleInputEmail1" class="form-label">Description</label>
                <textarea @@blur='touchField("description")' rows="8" v-model='taskForm.description' class="form-control" id="exampleInputEmail1" aria-describedby="emailHelp"></textarea>
                <span v-if='v$ && v$.description.$error' id="emailHelp" class="text-danger small">{{v$.description.$errors[0].$message}}</span>
            </div>
        </fieldset>
        @* User Assignment *@
        <div class="col d-flex flex-column">
            <label for="user-assignment" class="form-label">Assign Users</label>
            <div class='border flex-grow-1 p-3 d-flex flex-column'>
                 @* selected users *@
                <div class=" mb-3 ">
                    <ul class="list-unstyled row row-cols-4 gy-3 align-items-stretch mb-0 flex-grow-1 ">
                        <li v-for="user in selectedUsers" :key="user.id" class="col d-flex flex-column">
                            @* selected user card *@
                           <div class="p-2 flex-grow-1 d-flex flex-column align-items-center border border-success border-dashed border-opacity-10 rounded position-relative">
                             <i @@click='removeFromSelectedUsers(user); fetchUsers()' role="button" class="fa-solid fa-xmark position-absolute top-0 end-0 me-1 mt-1 text-danger"></i>
                             <img class="assigned-user-img rounded-pill border mx-auto" :src="user.image ? user.image : '/images/user-placeholder.png'" alt="">
                             <p class="text-center mb-0">{{ user.name }}</p>
                           </div>
                        </li>
                        @* no users selected *@
                        <li class='small text-center w-100 align-self-center' v-if="selectedUsers.length === 0">No users selected</li>
                    </ul>
                </div>
              <div class="flex-grow-1 d-flex flex-column">
                <input @@input='fetchUsers' v-model='searchQuery' type="text" class="form-control mb-4" placeholder="Search users...">
                @* users to search and select *@
                <ul class="list-unstyled row row-cols-4 gy-3 align-items-stretch mb-0 flex-grow-1">
                    @* user card *@
                    <li v-for="user in users" :key="user.id" class="col">
                        <input type="checkbox" :id="'user-' + user.id" v-model="taskForm.assignedToIds" :value="user.id" class="form-check-input d-none">
                        <label @@click='addToSelectedUsers(user); removeFromUsers(user)' :for="'user-' + user.id" class="d-flex flex-column  gap-2 cursor-pointer">
                            <img class="assigned-user-img rounded-pill border mx-auto" :src="user.image ? user.image : '/images/user-placeholder.png'" alt="">
                            <p class="text-center mb-0">{{ user.name }}</p>
                        </label>
                    </li>
                    @* no users found *@
                    <li class='small text-center w-100 align-self-center' v-if="users.length === 0 && !isUsersLoading">No users found</li>
                    <div class="spinner-border mx-auto align-self-center" role="status" v-if="isUsersLoading" >
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </ul>
              </div>
            </div>
        </div>
    </form>
</section>

@section Scripts {
    <script type='module'>
        const { useVuelidate } = window.Vuelidate;
        const { required, email, minLength, maxLength, helpers} = window.VuelidateValidators;

        const isTodayOrFuture = helpers.withMessage(
        'Date and time must be in the future or now',
        value => {
            if (!value) return true; // If no value, consider it valid (not required)

            const now = new Date();
            now.setMinutes(now.getMinutes() - 1);
            const selectedDate = new Date(value);
            return selectedDate >= now;
        });

        const isAfterStartDate = helpers.withMessage(
        'End date must be after start date',
        function(value, siblings) {
            if (!value || !siblings.startDate) return true;

            const start = new Date(siblings.startDate);
            const end = new Date(value);

            return end > start;
        });

        var UsersEdit= Vue.createApp({
            components:{
            },
            data() {
                return {
                  taskForm: {
                    name: '',
                    description: '',
                    startDate: '',
                    endDate: '',
                    assignedToIds: [],
                  },
                  rules: {
                    name: {required, minLength: minLength(3), maxLength: maxLength(150)},
                    description: {minLength: minLength(3), maxLength: maxLength(1500)},
                    startDate: {required,isTodayOrFuture},
                    endDate: {
                        required,
                       isAfterStartDate
                    },
                    assignedToIds: {},
                  },
                  v$:null,
                  users: [],
                  selectedUsers: [],
                  searchQuery: '',
                  taskId:null,
                  isUsersLoading: false
                };
            },
            computed:{
                isEditMode(){
                    return this.taskId ? true : false;
                }
            },
            methods: {
                touchField(fieldName){
                    this.v$[fieldName].$touch()
                },
                submitForm(){
                    this.v$.$validate();
                    if(this.v$.$error) return;

                    if(this.isEditMode){
                        this.updateTaskAsync();
                    }else{
                        this.createTaskAsync();
                    }
                },
                addToSelectedUsers(user){
                    if(this.selectedUsers.includes(user)) return;
                    this.selectedUsers.push(user);
                    this.taskForm.assignedToIds.push(user.id);
                    this.touchField('assignedToIds');
                },
                removeFromSelectedUsers(user){
                    this.selectedUsers = this.selectedUsers.filter(u => u.id !== user.id);
                    this.taskForm.assignedToIds = this.taskForm.assignedToIds.filter(id => id !== user.id);
                    this.touchField('assignedToIds');
                },
                removeFromUsers(user){
                    this.users = this.users.filter(u => u.id !== user.id);
                },
                createTaskAsync(){
                    this.taskForm.startDate = new Date(this.taskForm.startDate).toISOString();
                    this.taskForm.endDate = new Date(this.taskForm.endDate).toISOString();

                    axios.post('/Tasks/Create', this.taskForm)
                    .then(resp=>{
                          Swal.fire('Created!',"Task has been created",'success')
                         .then(()=>{
                           this.navigateToTasksPage();
                        });
                    });
                },
                navigateToTasksPage(){
                    window.location.href=`/Tasks/Index`; 
                },
                async fetchTask(id){
                   try{
                    loader.show();
                     const resp = await axios.get(`/Tasks/GetById/${id}`);
                     loader.hide();
                     this.selectedUsers = resp.data.responseData.assignedTo || [];
                      this.fillFormWithTaskInfo(resp.data.responseData);
                   }catch(error){
                       loader.hide();
                      this.navigateToTasksPage();
                   }
                },
                fetchUsers(){
                    this.isUsersLoading = true;
                    axios.post(`/Users/GetAvailableUsersForTask`,{
                        searchTerm: this.searchQuery,
                        pageSize: 12,
                        excludedUserIds: this.selectedUsers.map(u => u.id)
                    })
                    .then(resp=>{
                        this.users=resp.data.responseData;
                        this.isUsersLoading = false;
                    })
                    .catch(error=>{
                        this.isUsersLoading = false;
                    });
                },
                fillFormWithTaskInfo(task){
                    this.taskForm.name = task.name;
                    this.taskForm.description = task.description;
                    this.taskForm.startDate = task.startDate;
                    this.taskForm.endDate = task.endDate;
                    this.taskForm.assignedToIds = task.assignedTo.map(u => u.id) || [];
                },
                updateTaskAsync(){
                    axios.put(`/Tasks/Update/${this.taskId}`,{
                        ...this.taskForm,
                    })
                    .then(resp=>{
                        Swal.fire('Updated!',"Task has been updated",'success')
                        .then(()=>{
                            this.navigateToTasksPage();
                        });
                    });
                },
                
            },
            async mounted() {
                this.v$ = useVuelidate(this.rules,this.taskForm);

                this.taskId = '@(ViewBag.Id)';
                if(this.isEditMode){
                    await this.fetchTask(this.taskId);
                }

                @* in edit mode wait till task is fetched *@
                this.fetchUsers();
            }
        }).mount("#tasks-edit");
    </script>
}